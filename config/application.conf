# Akka configurations
akka {
  loglevel = "{{ .Values.logback.level | upper }}"
  extensions = ["akka.cluster.pubsub.DistributedPubSub"]
  log-dead-letters = off
  log-dead-letters-during-shutdown = off
  http.parsing.max-uri-length = 64k
  actor {
    provider = cluster
    serialize-messages = on
    serializers {
      proto = "akka.remote.serialization.ProtobufSerializer"
    }
    serialization-bindings {
      "actors.serializer.Serializable" = proto
    }
  }
  remote {
    log-remote-lifecycle-events = off
    transport = tcp
    artery {
      canonical {
        hostname = ${?HOSTNAME}
        port = 25520
      }
      bind {
        hostname = 0.0.0.0
        port = 25520
      }
    }
  }
  management {
    http {
      hostname = ${?HOSTNAME}
      bind-hostname = 0.0.0.0
      port = 8558
      bind-port = 8558
    }
    health-checks {
      readiness-checks {
        stream = "healthcheck.StreamHealthCheck"
      }
    }
    cluster.bootstrap {
      contact-point-discovery {
        port-name = management
        protocol = tcp
        service-name = "{{ .Release.Name }}-discovery"
        service-namespace = "{{ .Release.Namespace }}.svc.cluster.local"
        discovery-method = akka-dns
        {{ if .Values.horizontalAutoscaler.enabled }}
        required-contact-point-nr = "{{ .Values.horizontalAutoscaler.minReplicas }}"
        {{ else }}
        required-contact-point-nr = 1
        {{ end }}
      }
    }
  }
  cluster {
    downing-provider-class = "akka.cluster.sbr.SplitBrainResolverProvider"
    {{- if .Values.leases.enabled }}
    split-brain-resolver {
      active-strategy = "lease-majority"
      lease-majority {
        lease-implementation = "akka.coordination.lease.kubernetes"
      }
    }
    singleton {
      use-lease = "akka.coordination.lease.kubernetes"
    }
    {{- end }}
    shutdown-after-unsuccessful-join-seed-nodes = 60s
    pub-sub {
      name = distributedPubSubMediator
      routing-logic = random
      send-to-dead-letters-when-no-subscribers = on
    }
  }
  coordinated-shutdown.exit-jvm = off
}

# Specific dispatcher to isolate the actors with blocking IO
blocking-io-dispatcher {
  executor = "thread-pool-executor"
  throughput = 1
  thread-pool-executor {
    fixed-pool-size = 10
  }
}

# Play configurations
play {
  akka {
    actor-system = "{{ .Release.Name }}"
  }
  server {
    pidfile.path = "/dev/null"
  }
  http {
    secret.key = ${?APPLICATION_SECRET}
    forwarded.trustedProxies=[{{ include "horizon.trustedProxies" . }}]
    session.maxAge = 15 minutes
  }
  filters {
    hosts.allowed = [{{ include "horizon.allowedHosts" . }}]
    enabled += "play.filters.cors.CORSFilter"
    csrf.cookie.name = csrf-token
    cors.exposedHeaders = ["X-Stream-Id"]
  }
  i18n.langs = ["en", "en-US"]
  modules {
    enabled += "play.modules.reactivemongo.ReactiveMongoModule"
    enabled += "modules.StreamModule"
  }
  assets {
    path = "/public"
    urlPrefix = "/assets"
  }
  mailer {
    host = {{ .Values.mailer.host | default "null" }}
    port = {{ .Values.mailer.port }}
    ssl = {{ .Values.mailer.ssl | ternary "yes" "no" }}
    tls = {{ .Values.mailer.tls | ternary "yes" "no" }}
    user = {{ .Values.mailer.user | quote | default "null" }}
    password = ${?MAILER_PASSWORD}
  }
}

# Kamon configurations
kamon {
  modules {
    apm-reporter.enabled = false
    prometheus-reporter.enabled = true
    host-metrics.enabled = false
  }
  prometheus {
    include-environment-tags = true
    embedded-server {
      hostname = 0.0.0.0
      port = 9095
    }
  }
}

# MongoDB configurations
mongodb.uri = ${?MONGODB_URI}

stream {

  # License file
  license.file = "/stream/license/stream.lic"

  # Events
  event.seal.secret = ${?EVENT_SEAL_SECRET}

  secret.manager.keyset.path = "/stream/keyset/keyset.json"

}

include file("etc/conf.d/custom.conf")